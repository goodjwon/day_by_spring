# 도서 주문 및 대여 시스템 작업 태스크

## 개발 진행 현황

### ✅ 완료된 작업
- [x] 프로젝트 기본 구조 설정
- [x] 기본 Entity 설계 (Member, Book, Order, OrderItem, Loan)
- [x] Repository 계층 구현 (인터페이스 + JPA 구현체)
- [x] 기본 Controller 구현 (BookstoreController)
- [x] 기본 Service 구현 (OrderService + 구현체)
- [x] Strategy 패턴 적용 (결제 시스템)
- [x] IoC/DI 패턴 적용
- [x] 단위 테스트 작성 (Repository 계층)
- [x] 설정 파일 구성 (application.yml)
- [x] 초기 데이터 설정 (data.sql)

## Phase 1: 핵심 기능 완성 (우선순위: 높음)

### 1.1 회원 관리 기능 강화
**작업 기간**: 2-3일  
**담당**: Backend Developer

#### 1.1.1 MemberService 구현 ⭐️ 핵심
- [ ] **MemberService 인터페이스** 작성
  ```java
  public interface MemberService {
      MemberResponse createMember(CreateMemberRequest request);
      MemberResponse updateMember(Long id, UpdateMemberRequest request);
      MemberResponse findMemberById(Long id);
      List<MemberResponse> findAllMembers(Pageable pageable);
      void upgradeMembership(Long memberId, MembershipType newType);
      boolean validateEmailDuplicate(String email);
      MemberLoanLimitInfo getMemberLoanLimitInfo(Long memberId);
  }
  ```

- [ ] **MemberServiceImpl 구현체** 작성
  - [ ] 회원 가입 로직 (`createMember`)
    - 이메일 중복 검증
    - 기본 멤버십 설정 (REGULAR)
    - 가입일 설정
    - 환영 이메일 발송
  - [ ] 회원 정보 수정 (`updateMember`)
    - 수정 권한 검증
    - 이메일 변경 시 중복 체크
  - [ ] 멤버십 업그레이드 (`upgradeMembership`)
    - 현재 멤버십 상태 확인
    - 업그레이드 조건 검증
    - 결제 연동 (PaymentService 호출)
  - [ ] 대여 제한 정보 조회 (`getMemberLoanLimitInfo`)
    - 현재 대여 권수 계산
    - 멤버십별 최대 대여 권수 반환

#### 1.1.2 회원 컨트롤러 구현
- [ ] `MemberController` 작성
  - [ ] `POST /api/members` - 회원 가입
  - [ ] `GET /api/members/{id}` - 회원 조회
  - [ ] `GET /api/members` - 회원 목록 조회
  - [ ] `PUT /api/members/{id}` - 회원 정보 수정
  - [ ] `PUT /api/members/{id}/membership` - 멤버십 업그레이드

#### 1.1.3 회원 DTO 작성
- [ ] `CreateMemberRequest` DTO
- [ ] `UpdateMemberRequest` DTO
- [ ] `MemberResponse` DTO
- [ ] `MemberListResponse` DTO

#### 1.1.4 회원 기능 테스트
- [ ] `MemberServiceTest` 작성
- [ ] `MemberControllerTest` 작성
- [ ] 통합 테스트 작성

### 1.2 대여 관리 기능 구현
**작업 기간**: 3-4일  
**담당**: Backend Developer

#### 1.2.1 LoanService 구현 ⭐️ 핵심  
- [ ] **LoanService 인터페이스** 작성
  ```java
  public interface LoanService {
      LoanResponse loanBook(LoanBookRequest request);
      LoanResponse returnBook(Long loanId);
      LoanResponse renewLoan(Long loanId);
      List<LoanResponse> findMemberLoans(Long memberId);
      List<LoanResponse> findOverdueLoans();
      boolean canLoanBook(Long memberId, Long bookId);
      BigDecimal calculateOverdueFee(Long loanId);
      LoanLimitCheckResult checkLoanLimit(Long memberId);
  }
  ```

- [ ] **LoanServiceImpl 구현체** 작성
  - [ ] 도서 대여 로직 (`loanBook`)
    - 회원 상태 확인 (SUSPENDED 불가)
    - 대여 권수 제한 확인 (REGULAR: 5권, PREMIUM: 10권)
    - 도서 가용성 확인
    - 대여일/반납예정일 설정 (2주)
    - 대여 확인 이메일 발송
  - [ ] 도서 반납 로직 (`returnBook`)
    - 대여 정보 조회 및 검증
    - 연체료 계산 (1일당 100원)
    - 반납일 기록
    - 도서 가용성 업데이트 (BookService 호출)
  - [ ] 대여 연장 로직 (`renewLoan`)
    - 연장 가능 여부 확인 (최대 1회)
    - 연체 상태 확인
    - 반납예정일 연장 (1주)
  - [ ] 대여 제한 확인 (`checkLoanLimit`)
    - 현재 대여 중인 도서 수 계산
    - 멤버십별 한도와 비교
    - 결과 객체 반환 (가능 여부, 남은 권수)
  - [ ] 연체료 계산 (`calculateOverdueFee`)
    - 반납예정일과 현재일 비교
    - 연체일수 × 일당 연체료(100원)
    - 최대 연체료 제한 (도서 가격의 50%)

#### 1.2.2 대여 컨트롤러 구현
- [ ] `LoanController` 작성
  - [ ] `POST /api/loans` - 도서 대여
  - [ ] `PUT /api/loans/{id}/return` - 도서 반납
  - [ ] `GET /api/loans` - 대여 목록 조회
  - [ ] `GET /api/loans/member/{memberId}` - 회원별 대여 목록
  - [ ] `GET /api/loans/overdue` - 연체 목록 조회
  - [ ] `GET /api/loans/active` - 미반납 목록 조회

#### 1.2.3 대여 DTO 작성
- [ ] `LoanBookRequest` DTO
- [ ] `LoanResponse` DTO
- [ ] `ReturnBookRequest` DTO
- [ ] `LoanListResponse` DTO

#### 1.2.4 대여 기능 테스트
- [ ] `LoanServiceTest` 작성
- [ ] `LoanControllerTest` 작성
- [ ] 대여 제한 로직 테스트
- [ ] 연체 계산 로직 테스트

### 1.3 주문 기능 완성
**작업 기간**: 2-3일  
**담당**: Backend Developer

#### 1.3.1 주문 서비스 기능 확장
- [ ] 기존 `OrderServiceImpl` 확장
  - [ ] 주문 상태 변경 로직 (`updateOrderStatus`)
  - [ ] 주문 취소 로직 (`cancelOrder`)
  - [ ] 주문 검색 로직 (`searchOrders`)

#### 1.3.2 주문 컨트롤러 기능 확장
- [ ] 기존 `BookstoreController`에서 주문 부분 분리
- [ ] `OrderController` 작성
  - [ ] `PUT /api/orders/{id}/status` - 주문 상태 변경
  - [ ] `DELETE /api/orders/{id}` - 주문 취소
  - [ ] `GET /api/orders/search` - 주문 검색

#### 1.3.3 주문 관련 DTO 추가
- [ ] `UpdateOrderStatusRequest` DTO
- [ ] `OrderSearchRequest` DTO
- [ ] `OrderDetailResponse` DTO

## Phase 2: Spring Boot 고급 기술 적용 (우선순위: 중간)

### 2.1 EmailService 및 PaymentService 구현 ⭐️ 고급 기능
**작업 기간**: 2-3일  
**담당**: Backend Developer

#### 2.1.1 EmailService 확장 및 템플릿 시스템
- [ ] **EmailService 인터페이스** 확장
  ```java
  public interface EmailService {
      void sendWelcomeEmail(Member member);
      void sendOrderConfirmationEmail(Order order);
      void sendLoanConfirmationEmail(Loan loan);
      void sendReturnReminderEmail(Loan loan);
      void sendOverdueNotificationEmail(Loan loan);
      void sendMembershipUpgradeEmail(Member member);
  }
  ```

- [ ] **EmailServiceImpl 구현체** 작성
  - [ ] 회원가입 환영 이메일 (`sendWelcomeEmail`)
    - HTML 템플릿 활용
    - 개인화된 인사말
    - 서비스 이용 가이드 포함
  - [ ] 주문 확인 이메일 (`sendOrderConfirmationEmail`)
    - 주문 상세 정보 포함
    - 배송 정보 안내
    - 결제 정보 요약
  - [ ] 대여 관련 이메일
    - 대여 확인 알림
    - 반납 예정일 알림 (1일 전)
    - 연체 경고 알림 (연체료 포함)
  
- [ ] **EmailTemplateService 구현**
  - [ ] Thymeleaf 템플릿 엔진 연동
  - [ ] 템플릿 파일 관리 (resources/templates/email/)
  - [ ] 다국어 지원 (i18n)

#### 2.1.2 PaymentService 완성 (Strategy 패턴)
- [ ] **PaymentService 및 Strategy 구현**
  ```java
  @Service
  public class PaymentServiceImpl implements PaymentService {
      private final List<PaymentStrategy> strategies;
      
      public PaymentResult processPayment(PaymentRequest request) {
          PaymentStrategy strategy = findStrategy(request.getMethod());
          return strategy.process(request);
      }
  }
  ```

- [ ] **결제 전략별 구현**
  - [ ] CreditCardPaymentStrategy
    - 카드번호 유효성 검증
    - CVV 검증
    - 한도 확인 (Mock)
  - [ ] BankTransferPaymentStrategy  
    - 계좌번호 형식 검증
    - 잔액 확인 (Mock)
    - 이체 한도 확인

#### 2.1.2 알림 템플릿 관리
- [ ] 이메일 템플릿 작성 (HTML)
- [ ] 템플릿 엔진 연동 (Thymeleaf)
- [ ] 다국어 지원 고려

#### 2.1.3 배치 작업 구현
- [ ] `@Scheduled`를 이용한 연체 확인 배치
- [ ] 연체 알림 발송 배치
- [ ] 통계 데이터 집계 배치

### 2.2 AOP 및 Event-Driven Architecture 구현 ⭐️ Spring 고급 기술
**작업 기간**: 3-4일  
**담당**: Backend Developer

#### 2.2.1 AOP (Aspect-Oriented Programming) 적용
- [ ] **@Transactional 최적화**
  ```java
  @Service
  @Transactional(readOnly = true)
  public class MemberServiceImpl {
      @Transactional // 쓰기 작업만 별도 트랜잭션
      public MemberResponse createMember(CreateMemberRequest request) {
          // 회원 생성 로직
      }
  }
  ```

- [ ] **@Cacheable 캐싱 적용**
  ```java
  @Service
  public class BookService {
      @Cacheable(value = "books", key = "#id")
      public BookResponse findBookById(Long id) {
          return bookRepository.findById(id)...;
      }
      
      @CacheEvict(value = "books", key = "#bookId")
      public void updateBook(Long bookId, UpdateBookRequest request) {
          // 캐시 무효화 후 업데이트
      }
  }
  ```

- [ ] **@Async 비동기 처리**
  ```java
  @Service
  public class EmailService {
      @Async("emailTaskExecutor")
      public CompletableFuture<Void> sendEmailAsync(EmailRequest request) {
          // 비동기 이메일 발송
      }
  }
  ```

#### 2.2.2 Event-Driven Architecture (이벤트 기반 아키텍처)
- [ ] **Domain Events 정의**
  ```java
  public class MemberRegisteredEvent {
      private final Member member;
      private final LocalDateTime occurredAt;
  }
  
  public class LoanCreatedEvent {
      private final Loan loan;
      private final LocalDateTime occurredAt;
  }
  ```

- [ ] **Event Publisher 구현**
  ```java
  @Service
  public class MemberService {
      @Autowired
      private ApplicationEventPublisher eventPublisher;
      
      public MemberResponse createMember(CreateMemberRequest request) {
          Member member = memberRepository.save(newMember);
          eventPublisher.publishEvent(new MemberRegisteredEvent(member));
          return MemberResponse.from(member);
      }
  }
  ```

- [ ] **Event Listeners 구현**
  ```java
  @Component
  public class MemberEventListener {
      @EventListener
      @Async
      public void handleMemberRegistered(MemberRegisteredEvent event) {
          emailService.sendWelcomeEmail(event.getMember());
      }
      
      @EventListener
      public void handleLoanCreated(LoanCreatedEvent event) {
          statisticsService.updateLoanStatistics(event.getLoan());
      }
  }
  ```

#### 2.2.3 통계 서비스 구현 (캐싱 + 배치 처리)
- [ ] **StatisticsService with Caching**
  ```java
  @Service
  public class StatisticsServiceImpl {
      @Cacheable(value = "loan-statistics", key = "#filter.hashCode()")
      public LoanStatisticsResponse getLoanStatistics(StatisticsFilter filter) {
          // 복잡한 집계 쿼리 실행
      }
      
      @Scheduled(fixedRate = 3600000) // 1시간마다
      @CacheEvict(value = "loan-statistics", allEntries = true)
      public void refreshStatisticsCache() {
          // 통계 캐시 갱신
      }
  }
  ```

- [ ] **배치 작업 스케줄링**
  ```java
  @Component
  public class LoanScheduler {
      @Scheduled(cron = "0 0 9 * * ?") // 매일 오전 9시
      public void sendReturnReminders() {
          List<Loan> dueSoonLoans = loanService.findLoansDueTomorrow();
          dueSoonLoans.forEach(loan -> 
              eventPublisher.publishEvent(new ReturnReminderEvent(loan))
          );
      }
      
      @Scheduled(cron = "0 0 0 * * ?") // 매일 자정
      public void processOverdueLoans() {
          List<Loan> overdueLoans = loanService.findOverdueLoans();
          overdueLoans.forEach(this::processOverdueLoan);
      }
  }
  ```

#### 2.2.2 통계 컨트롤러 구현
- [ ] `StatisticsController` 작성
  - [ ] `GET /api/statistics/loans` - 대여 통계
  - [ ] `GET /api/statistics/orders` - 주문 통계
  - [ ] `GET /api/statistics/members` - 회원 통계
  - [ ] `GET /api/statistics/popular-books` - 인기 도서

#### 2.2.3 통계 DTO 작성
- [ ] `LoanStatisticsResponse` DTO
- [ ] `OrderStatisticsResponse` DTO
- [ ] `PopularBookResponse` DTO

### 2.3 Spring Data JPA 고급 기능 및 Validation ⭐️ 데이터 처리 최적화
**작업 기간**: 2-3일  
**담당**: Backend Developer

#### 2.3.1 Spring Data JPA 고급 기능 적용
- [ ] **@Query를 이용한 커스텀 쿼리**
  ```java
  @Repository
  public interface LoanRepository extends JpaRepository<Loan, Long> {
      @Query("SELECT l FROM Loan l JOIN FETCH l.member JOIN FETCH l.book " +
             "WHERE l.returnDate IS NULL AND l.dueDate < :date")
      List<Loan> findOverdueLoansWithDetails(@Param("date") LocalDateTime date);
      
      @Query(value = "SELECT * FROM loan WHERE loan_date BETWEEN :start AND :end " +
                     "ORDER BY loan_date DESC", nativeQuery = true)
      List<Loan> findLoansByDateRange(@Param("start") LocalDateTime start, 
                                     @Param("end") LocalDateTime end);
  }
  ```

- [ ] **Specification을 이용한 동적 쿼리**
  ```java
  @Service
  public class BookService {
      public List<BookResponse> searchBooks(BookSearchCriteria criteria) {
          Specification<Book> spec = Specification.where(null);
          
          if (criteria.getTitle() != null) {
              spec = spec.and(BookSpecifications.titleContains(criteria.getTitle()));
          }
          if (criteria.getAuthor() != null) {
              spec = spec.and(BookSpecifications.authorEquals(criteria.getAuthor()));
          }
          
          return bookRepository.findAll(spec)...;
      }
  }
  ```

- [ ] **@EntityGraph로 N+1 문제 해결**
  ```java
  @EntityGraph(attributePaths = {"orderItems", "orderItems.book"})
  @Query("SELECT o FROM Order o WHERE o.id = :id")
  Optional<Order> findByIdWithItems(@Param("id") Long id);
  ```

- [ ] **Auditing 기능 구현**
  ```java
  @MappedSuperclass
  @EntityListeners(AuditingEntityListener.class)
  public abstract class BaseEntity {
      @CreatedDate
      private LocalDateTime createdDate;
      
      @LastModifiedDate
      private LocalDateTime modifiedDate;
      
      @CreatedBy
      private String createdBy;
      
      @LastModifiedBy
      private String modifiedBy;
  }
  ```

#### 2.3.2 Bean Validation 및 Exception Handling
- [ ] **DTO Validation 강화**
  ```java
  public class CreateMemberRequest {
      @NotBlank(message = "이름은 필수입니다")
      @Size(min = 2, max = 50, message = "이름은 2자 이상 50자 이하여야 합니다")
      private String name;
      
      @Email(message = "올바른 이메일 형식이 아닙니다")
      @NotBlank(message = "이메일은 필수입니다")
      private String email;
      
      @Valid
      @NotNull
      private MembershipRequest membership;
  }
  ```

- [ ] **Custom Validator 구현**
  ```java
  @Component
  public class MemberValidator {
      @Autowired
      private MemberRepository memberRepository;
      
      public void validateEmailUnique(String email) {
          if (memberRepository.existsByEmail(email)) {
              throw new DuplicateEmailException("이미 사용 중인 이메일입니다: " + email);
          }
      }
  }
  ```

- [ ] **@ControllerAdvice로 글로벌 예외 처리**
  ```java
  @ControllerAdvice
  public class GlobalExceptionHandler {
      @ExceptionHandler(ValidationException.class)
      public ResponseEntity<ErrorResponse> handleValidation(ValidationException ex) {
          return ResponseEntity.badRequest().body(
              ErrorResponse.of("VALIDATION_ERROR", ex.getMessage())
          );
      }
      
      @ExceptionHandler(EntityNotFoundException.class)
      public ResponseEntity<ErrorResponse> handleNotFound(EntityNotFoundException ex) {
          return ResponseEntity.notFound().build();
      }
      
      @ExceptionHandler(BusinessException.class)
      public ResponseEntity<ErrorResponse> handleBusiness(BusinessException ex) {
          return ResponseEntity.badRequest().body(
              ErrorResponse.of(ex.getErrorCode(), ex.getMessage())
          );
      }
  }
  ```

#### 2.3.3 Configuration 및 Properties 관리
- [ ] **@ConfigurationProperties 활용**
  ```java
  @ConfigurationProperties(prefix = "library")
  @Data
  @Component
  public class LibraryProperties {
      private LoanConfig loan = new LoanConfig();
      private NotificationConfig notification = new NotificationConfig();
      private PaymentConfig payment = new PaymentConfig();
      
      @Data
      public static class LoanConfig {
          private int defaultPeriodWeeks = 2;
          private int maxRenewalCount = 2;
          private BigDecimal dailyOverdueFee = new BigDecimal("100");
      }
  }
  ```

- [ ] **@Profile을 이용한 환경별 설정**
  ```java
  @Configuration
  @Profile("prod")
  public class ProductionConfig {
      @Bean
      public EmailService emailService() {
          return new SmtpEmailService();
      }
  }
  
  @Configuration  
  @Profile("test")
  public class TestConfig {
      @Bean
      public EmailService emailService() {
          return new MockEmailService();
      }
  }
  ```

#### 2.3.2 도서 컨트롤러 확장
- [ ] 기존 `BookstoreController`에서 도서 부분 분리
- [ ] `BookController` 작성
  - [ ] `POST /api/books` - 도서 등록
  - [ ] `PUT /api/books/{id}` - 도서 수정
  - [ ] `DELETE /api/books/{id}` - 도서 삭제
  - [ ] `GET /api/books/search` - 도서 검색

## Phase 3: 품질 향상 및 최적화 (우선순위: 낮음)

### 3.1 Service Layer 테스트 전략 ⭐️ 품질 보장
**작업 기간**: 3-4일  
**담당**: Backend Developer

#### 3.1.1 Service 단위 테스트 전략
- [ ] **MemberServiceTest**
  ```java
  @ExtendWith(MockitoExtension.class)
  class MemberServiceTest {
      @Mock private MemberRepository memberRepository;
      @Mock private EmailService emailService;
      @InjectMocks private MemberServiceImpl memberService;
      
      @Test
      void 회원가입_성공() {
          // Given, When, Then
      }
      
      @Test 
      void 이메일중복_예외발생() {
          // 중복 이메일 시 예외 검증
      }
  }
  ```

- [ ] **LoanServiceTest** (복잡한 비즈니스 로직 테스트)
  - [ ] 대여 가능 여부 검증 테스트
  - [ ] 대여 제한 초과 시 예외 테스트
  - [ ] 연체료 계산 로직 테스트
  - [ ] 반납 처리 통합 테스트

- [ ] **Service 간 의존성 테스트**
  ```java
  @SpringBootTest
  @Transactional
  class ServiceIntegrationTest {
      @Test
      void 회원가입_후_도서대여_전체플로우() {
          // 1. 회원 가입 (MemberService)
          // 2. 도서 대여 (LoanService)
          // 3. 이메일 발송 확인 (EmailService)
      }
  }
  ```

#### 3.1.2 Service Layer Mock 전략
- [ ] **Repository Layer Mocking**
  - 각 Service는 Repository를 Mock으로 처리
  - 실제 DB 연동 없이 비즈니스 로직만 테스트
  
- [ ] **Service 간 의존성 Mocking**
  ```java
  // LoanService 테스트 시
  @Mock private MemberService memberService;  // 회원 정보 조회
  @Mock private BookService bookService;      // 도서 정보 조회  
  @Mock private EmailService emailService;    // 알림 발송
  ```

- [ ] **외부 의존성 Mocking**
  - PaymentService의 외부 결제 API Mock
  - EmailService의 SMTP 발송 Mock

#### 3.1.2 통합 테스트 작성
- [ ] 회원 가입부터 도서 대여까지 전체 플로우 테스트
- [ ] 주문 생성부터 배송까지 전체 플로우 테스트
- [ ] 동시성 테스트 (동일 도서 대여 경쟁 조건)

#### 3.1.3 성능 테스트
- [ ] JMeter를 이용한 부하 테스트
- [ ] 응답 시간 측정 및 최적화

### 3.2 예외 처리 및 검증 강화
**작업 기간**: 2일  
**담당**: Backend Developer

#### 3.2.1 글로벌 예외 처리
- [ ] `@ControllerAdvice`를 이용한 전역 예외 처리
- [ ] 커스텀 예외 클래스 작성
- [ ] 오류 응답 표준화

#### 3.2.2 입력 검증 강화
- [ ] Bean Validation 적용 (`@Valid`, `@NotNull` 등)
- [ ] 커스텀 Validator 작성
- [ ] 비즈니스 규칙 검증 강화

### 3.3 성능 최적화
**작업 기간**: 2-3일  
**담당**: Backend Developer

#### 3.3.1 데이터베이스 최적화
- [ ] JPA 쿼리 최적화 (N+1 문제 해결)
- [ ] 인덱스 추가 및 최적화
- [ ] 페이징 처리 개선

#### 3.3.2 캐싱 적용
- [ ] Spring Cache 적용
- [ ] Redis 연동 (선택사항)
- [ ] 캐시 무효화 전략 수립

## Phase 4: 배포 및 운영 (우선순위: 낮음)

### 4.1 환경 설정 분리
**작업 기간**: 1-2일  
**담당**: DevOps

#### 4.1.1 프로파일별 설정
- [ ] 개발(dev), 테스트(test), 운영(prod) 프로파일 분리
- [ ] 환경변수를 이용한 민감 정보 관리
- [ ] Docker 컨테이너화

#### 4.1.2 로깅 체계 구축
- [ ] Logback 설정 최적화
- [ ] 로그 레벨 환경별 분리
- [ ] 로그 파일 로테이션 설정

### 4.2 모니터링 및 건강성 체크
**작업 기간**: 1-2일  
**담당**: DevOps

#### 4.2.1 애플리케이션 모니터링
- [ ] Spring Boot Actuator 설정
- [ ] Health Check 엔드포인트 구성
- [ ] 메트릭 수집 설정

#### 4.2.2 데이터베이스 모니터링
- [ ] 커넥션 풀 모니터링
- [ ] 쿼리 성능 모니터링
- [ ] 데이터베이스 백업 전략

## 작업 우선순위 및 일정

### Sprint 1 (1주차): 핵심 기능 구현
1. **회원 관리 기능 강화** (3일)
2. **대여 관리 기능 구현** (4일)

### Sprint 2 (2주차): 주문 및 알림 기능
1. **주문 기능 완성** (3일)
2. **알림 시스템 구현** (3일)
3. **도서 관리 기능 강화** (1일)

### Sprint 3 (3주차): 품질 및 최적화
1. **통계 및 리포트 기능** (4일)
2. **테스트 커버리지 향상** (3일)

### Sprint 4 (4주차): 마무리 및 배포
1. **예외 처리 및 검증 강화** (2일)
2. **성능 최적화** (3일)
3. **배포 및 운영 준비** (2일)

## 리스크 및 고려사항

### 기술적 리스크
- **동시성 문제**: 동일 도서에 대한 동시 대여 신청 처리
- **성능 이슈**: 대용량 데이터 조회 시 응답 시간
- **데이터 일관성**: 트랜잭션 처리 및 롤백 전략

### 해결 방안
- **낙관적 락** 사용으로 동시성 제어
- **페이징 및 인덱스** 활용으로 성능 최적화
- **@Transactional** 적절한 활용

### 학습 목표
- Spring Boot 핵심 기능 이해
- 디자인 패턴 실무 적용
- 테스트 주도 개발 (TDD) 경험
- 성능 최적화 기법 학습

## 완료 기준 (Definition of Done)

각 작업의 완료 기준:
1. **기능 구현 완료**: 요구사항에 맞는 기능 구현
2. **단위 테스트 작성**: 최소 80% 커버리지
3. **통합 테스트 통과**: 전체 플로우 정상 동작
4. **코드 리뷰 완료**: 코드 품질 검증
5. **문서화 업데이트**: API 문서 및 README 업데이트