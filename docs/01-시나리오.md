# 도서 주문 및 대여 시스템 시나리오

## 프로젝트 개요

Spring Boot를 활용한 도서관 및 서점 통합 시스템으로, 도서 주문과 대여 서비스를 제공하는 플랫폼입니다.

## 주요 시나리오

### 1. 회원 관리 시나리오

#### 1.1 회원 가입
- **액터**: 신규 사용자
- **시나리오**: 
  1. 사용자가 회원가입 페이지에 접속한다
  2. 이름, 이메일, 비밀번호를 입력한다
  3. 이메일 중복 검증을 진행한다
  4. 기본 멤버십 타입(REGULAR)으로 회원가입이 완료된다
  5. 환영 이메일이 발송된다

#### 1.2 멤버십 업그레이드
- **액터**: 기존 회원
- **시나리오**:
  1. 회원이 멤버십 업그레이드를 신청한다
  2. 결제를 진행한다
  3. 멤버십이 PREMIUM으로 업그레이드된다
  4. 대출 가능 권수가 5권에서 10권으로 증가한다

### 2. 도서 주문 시나리오

#### 2.1 도서 구매
- **액터**: 회원
- **시나리오**:
  1. 회원이 도서 목록을 조회한다
  2. 원하는 도서를 장바구니에 담는다
  3. 주문서를 작성한다
  4. 결제 방식을 선택한다 (신용카드/계좌이체)
  5. 결제를 완료한다
  6. 주문이 생성되고 상태가 PENDING으로 설정된다
  7. 주문 확인 이메일이 발송된다

#### 2.2 주문 처리
- **액터**: 관리자
- **시나리오**:
  1. 관리자가 새로운 주문을 확인한다
  2. 재고를 확인하고 주문을 승인한다
  3. 주문 상태가 CONFIRMED로 변경된다
  4. 배송을 준비한다
  5. 주문 상태가 SHIPPED로 변경된다
  6. 배송 완료 시 DELIVERED로 변경된다

### 3. 도서 대여 시나리오

#### 3.1 도서 대여
- **액터**: 회원
- **시나리오**:
  1. 회원이 대여 가능한 도서를 검색한다
  2. 원하는 도서의 대여 가능 여부를 확인한다
  3. 대여 신청을 진행한다
  4. 회원의 현재 대여 권수를 확인한다
  5. 멤버십 타입별 최대 대여 권수를 초과하지 않으면 대여가 승인된다
  6. 대여 정보가 생성되고 반납 예정일이 설정된다 (2주 후)
  7. 도서가 대여 불가 상태로 변경된다

#### 3.2 도서 반납
- **액터**: 회원
- **시나리오**:
  1. 회원이 대여 중인 도서 목록을 확인한다
  2. 반납할 도서를 선택한다
  3. 반납 처리가 진행된다
  4. 반납일이 기록된다
  5. 도서가 다시 대여 가능 상태로 변경된다
  6. 연체료가 있다면 계산하여 청구한다

#### 3.3 연체 관리
- **액터**: 시스템 (배치 작업)
- **시나리오**:
  1. 매일 자정에 연체 도서를 확인한다
  2. 반납 예정일을 초과한 대여를 식별한다
  3. 연체 회원에게 알림 이메일을 발송한다
  4. 연체가 심각한 경우 계정을 일시 정지(SUSPENDED)한다

### 4. 통계 및 관리 시나리오

#### 4.1 대여 통계 조회
- **액터**: 관리자
- **시나리오**:
  1. 관리자가 통계 페이지에 접속한다
  2. 기간별 대여 현황을 조회한다
  3. 인기 도서 순위를 확인한다
  4. 회원별 대여 이력을 조회한다

#### 4.2 재고 관리
- **액터**: 관리자
- **시나리오**:
  1. 관리자가 도서 재고 현황을 확인한다
  2. 재고가 부족한 도서를 식별한다
  3. 신규 도서를 등록한다
  4. 기존 도서 정보를 수정한다

## 기술 시나리오

### 5. Spring Boot 핵심 기술 적용

#### 5.1 IoC/DI 패턴 (Dependency Injection)
- **Spring Container**가 의존성을 주입하여 객체 간 결합도를 낮춘다
- **@Autowired, @RequiredArgsConstructor**를 활용한 생성자 주입
- Repository, Service, Controller 계층에서 의존성 주입을 활용한다
- **순환 참조 방지** 및 **테스트 용이성** 확보

#### 5.2 AOP (Aspect-Oriented Programming) 패턴
- **@Transactional**을 이용한 선언적 트랜잭션 관리
- **@Cacheable**을 이용한 메서드 레벨 캐싱
- **@Async**를 이용한 비동기 처리 (이메일 발송)
- **@EventListener**를 이용한 이벤트 기반 아키텍처
- 로깅, 보안, 성능 측정 등 횡단 관심사 분리

#### 5.3 디자인 패턴 적용

##### 5.3.1 Strategy 패턴
- 결제 방식(신용카드, 계좌이체)에 따라 다른 결제 전략을 적용한다
- **PaymentStrategy 인터페이스**와 구체적 구현체들
- 새로운 결제 방식 추가 시 기존 코드 수정 없이 확장 가능하다

##### 5.3.2 Repository 패턴
- 데이터 접근 로직을 캡슐화하여 비즈니스 로직과 분리한다
- 인터페이스와 JPA 구현체를 분리하여 테스트 가능성을 높인다
- **Spring Data JPA**의 자동 구현체 생성 활용

##### 5.3.3 Template Method 패턴
- **AbstractEmailService**를 통한 이메일 발송 공통 로직 추상화
- **EmailTemplateService**에서 템플릿별 구체적 구현

##### 5.3.4 Factory 패턴
- **PaymentStrategyFactory**를 통한 결제 전략 선택
- **EmailTemplateFactory**를 통한 템플릿 타입별 생성

##### 5.3.5 Observer 패턴 (Event-Driven)
- **Spring Events**를 활용한 도메인 이벤트 처리
```java
// 이벤트 발행
@Service
public class MemberService {
    @EventPublisher
    private ApplicationEventPublisher eventPublisher;
    
    public void createMember(CreateMemberRequest request) {
        Member member = memberRepository.save(newMember);
        eventPublisher.publishEvent(new MemberRegisteredEvent(member));
    }
}

// 이벤트 처리
@Component
public class MemberEventListener {
    @EventListener
    @Async
    public void handleMemberRegistered(MemberRegisteredEvent event) {
        emailService.sendWelcomeEmail(event.getMember());
    }
}
```

### 6. Spring Boot 고급 기능 활용

#### 6.1 Spring Data JPA 고급 기능
- **@Query**를 이용한 커스텀 JPQL/Native Query
- **Specification**을 이용한 동적 쿼리 작성
- **@EntityGraph**를 이용한 N+1 문제 해결
- **Auditing** 기능으로 생성/수정 일시 자동 관리
```java
@Entity
@EntityListeners(AuditingEntityListener.class)
public class BaseEntity {
    @CreatedDate
    private LocalDateTime createdDate;
    
    @LastModifiedDate 
    private LocalDateTime modifiedDate;
    
    @CreatedBy
    private String createdBy;
}
```

#### 6.2 Validation 및 Exception Handling
- **Bean Validation**을 이용한 입력 데이터 검증
```java
public class CreateMemberRequest {
    @NotBlank(message = "이름은 필수입니다")
    private String name;
    
    @Email(message = "올바른 이메일 형식이 아닙니다")
    private String email;
}
```

- **@ControllerAdvice**를 이용한 글로벌 예외 처리
```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(ValidationException ex) {
        return ResponseEntity.badRequest().body(
            ErrorResponse.of("VALIDATION_ERROR", ex.getMessage())
        );
    }
}
```

#### 6.3 Configuration 및 Properties 관리
- **@ConfigurationProperties**를 이용한 설정 외부화
```java
@ConfigurationProperties(prefix = "library")
@Data
public class LibraryProperties {
    private LoanConfig loan = new LoanConfig();
    private NotificationConfig notification = new NotificationConfig();
    
    @Data
    public static class LoanConfig {
        private int defaultPeriodWeeks = 2;
        private int maxRenewalCount = 2;
    }
}
```

- **@Profile**을 이용한 환경별 설정 분리
```java
@Service
@Profile("!test")
public class SmtpEmailService implements EmailService {
    // 실제 SMTP 이메일 발송
}

@Service
@Profile("test")
public class MockEmailService implements EmailService {
    // 테스트용 Mock 이메일 발송
}
```

#### 6.4 Security 및 인증/인가
- **Spring Security**를 이용한 API 보안
- **JWT Token** 기반 인증 (선택적 구현)
- **Method Level Security**를 이용한 세밀한 권한 제어
```java
@PreAuthorize("hasRole('ADMIN') or #memberId == authentication.principal.id")
public MemberResponse findMemberById(Long memberId) {
    // 관리자이거나 본인만 조회 가능
}
```

#### 6.5 Testing 전략
- **@SpringBootTest**를 이용한 통합 테스트
- **@DataJpaTest**를 이용한 Repository 계층 테스트
- **@WebMvcTest**를 이용한 Controller 계층 테스트
- **@MockBean**을 이용한 Service 계층 Mock
- **TestContainers**를 이용한 실제 DB 테스트
```java
@SpringBootTest
@Testcontainers
class OrderServiceIntegrationTest {
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
}
```

### 7. 성능 최적화 기술

#### 7.1 캐싱 전략
- **Spring Cache Abstraction** 활용
- **@Cacheable, @CacheEvict, @CachePut** 어노테이션 사용
- **Redis** 연동으로 분산 캐싱 (선택적)
```java
@Service
public class BookService {
    @Cacheable(value = "books", key = "#id")
    public BookResponse findBookById(Long id) {
        return bookRepository.findById(id)...;
    }
    
    @CacheEvict(value = "books", key = "#bookId")
    public void updateBook(Long bookId, UpdateBookRequest request) {
        // 캐시 무효화 후 업데이트
    }
}
```

#### 7.2 비동기 처리
- **@Async**를 이용한 비동기 메서드 실행
- **CompletableFuture**를 이용한 비동기 결과 처리
- **@Scheduled**를 이용한 배치 작업
```java
@Service
public class EmailService {
    @Async("emailTaskExecutor")
    public CompletableFuture<Void> sendEmailAsync(EmailRequest request) {
        // 비동기 이메일 발송
        return CompletableFuture.completedFuture(null);
    }
}

@Component
public class LoanScheduler {
    @Scheduled(cron = "0 0 9 * * ?") // 매일 오전 9시
    public void sendReturnReminders() {
        // 반납 알림 배치 작업
    }
}
```

#### 7.3 데이터베이스 최적화
- **Connection Pool** 최적화 (HikariCP)
- **JPA 2nd Level Cache** 활용
- **Database Indexing** 전략
- **Query Optimization** 및 **Lazy Loading** 활용

### 8. 에러 핸들링 및 보상 트랜잭션

#### 8.1 글로벌 예외 처리 전략
```java
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        log.warn("Business exception occurred: {}", ex.getMessage());
        return ResponseEntity.badRequest().body(
            ErrorResponse.builder()
                .errorCode(ex.getErrorCode())
                .message(ex.getMessage())
                .timestamp(LocalDateTime.now())
                .build()
        );
    }
    
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(ValidationException ex) {
        log.warn("Validation error: {}", ex.getBindingResult());
        return ResponseEntity.badRequest().body(
            ErrorResponse.builder()
                .errorCode("VALIDATION_ERROR")
                .message("입력값이 올바르지 않습니다")
                .details(extractFieldErrors(ex.getBindingResult()))
                .build()
        );
    }
    
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleEntityNotFound(EntityNotFoundException ex) {
        log.warn("Entity not found: {}", ex.getMessage());
        return ResponseEntity.notFound().build();
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        log.error("Unexpected error occurred", ex);
        return ResponseEntity.internalServerError().body(
            ErrorResponse.builder()
                .errorCode("INTERNAL_SERVER_ERROR")
                .message("서버 오류가 발생했습니다")
                .build()
        );
    }
}
```

#### 8.2 보상 트랜잭션 (Saga Pattern)
**도서 대여 실패 시 보상 처리:**
```java
@Service
@Transactional
public class LoanSagaService {
    
    public LoanResponse loanBookWithCompensation(LoanBookRequest request) {
        try {
            // 1. 회원 상태 확인
            Member member = validateMember(request.getMemberId());
            
            // 2. 도서 가용성 확인 및 예약
            Book book = reserveBook(request.getBookId());
            
            // 3. 대여 제한 확인
            validateLoanLimit(member);
            
            // 4. 대여 생성
            Loan loan = createLoan(member, book);
            
            // 5. 이메일 발송
            sendLoanConfirmationEmail(loan);
            
            return LoanResponse.from(loan);
            
        } catch (Exception ex) {
            // 보상 트랜잭션 실행
            executeCompensation(request, ex);
            throw ex;
        }
    }
    
    @Async
    private void executeCompensation(LoanBookRequest request, Exception originalEx) {
        try {
            // 1. 도서 예약 해제
            unreserveBook(request.getBookId());
            
            // 2. 실패 로그 기록
            logLoanFailure(request, originalEx);
            
            // 3. 관리자 알림
            notifyAdminOfFailure(request, originalEx);
            
        } catch (Exception compensationEx) {
            log.error("Compensation failed for loan request: {}", request, compensationEx);
        }
    }
}
```

**주문 결제 실패 시 보상 처리:**
```java
@Service
public class OrderSagaService {
    
    @Transactional
    public OrderResponse processOrderWithCompensation(CreateOrderRequest request) {
        SagaTransaction saga = new SagaTransaction();
        
        try {
            // 1. 주문 생성
            Order order = createOrder(request);
            saga.addCompensation(() -> cancelOrder(order.getId()));
            
            // 2. 재고 차감
            reserveInventory(request.getBookIds());
            saga.addCompensation(() -> releaseInventory(request.getBookIds()));
            
            // 3. 결제 처리
            PaymentResult payment = processPayment(order);
            saga.addCompensation(() -> refundPayment(payment.getTransactionId()));
            
            // 4. 주문 확정
            confirmOrder(order.getId());
            
            return OrderResponse.from(order);
            
        } catch (Exception ex) {
            saga.executeCompensations();
            throw ex;
        }
    }
}
```

### 9. 모니터링 및 로깅

#### 9.1 구조화된 로깅 전략
```java
@Component
@Slf4j
public class LoggingAspect {
    
    @Around("@annotation(Loggable)")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        
        // MDC에 요청 정보 추가
        MDC.put("method", methodName);
        MDC.put("class", className);
        MDC.put("traceId", UUID.randomUUID().toString());
        
        long startTime = System.currentTimeMillis();
        
        try {
            log.info("Method execution started: {}.{}", className, methodName);
            Object result = joinPoint.proceed();
            
            long executionTime = System.currentTimeMillis() - startTime;
            log.info("Method execution completed: {}.{} in {}ms", 
                className, methodName, executionTime);
            
            return result;
            
        } catch (Exception ex) {
            long executionTime = System.currentTimeMillis() - startTime;
            log.error("Method execution failed: {}.{} in {}ms", 
                className, methodName, executionTime, ex);
            throw ex;
        } finally {
            MDC.clear();
        }
    }
}
```

**비즈니스 로직별 구체적 로깅:**
```java
@Service
@Slf4j
public class LoanServiceImpl implements LoanService {
    
    @Override
    @Loggable
    public LoanResponse loanBook(LoanBookRequest request) {
        log.info("도서 대여 요청 - 회원ID: {}, 도서ID: {}", 
            request.getMemberId(), request.getBookId());
        
        try {
            // 비즈니스 로직...
            log.info("도서 대여 성공 - 대여ID: {}", loan.getId());
            return LoanResponse.from(loan);
            
        } catch (LoanLimitExceededException ex) {
            log.warn("대여 권수 초과 - 회원ID: {}, 현재 대여: {}권, 한도: {}권", 
                request.getMemberId(), ex.getCurrentLoans(), ex.getMaxLimit());
            throw ex;
        }
    }
}
```

#### 9.2 Spring Boot Actuator 모니터링
```java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    @Autowired
    private LoanRepository loanRepository;
    
    @Override
    public Health health() {
        try {
            // 데이터베이스 연결 확인
            long overdueCount = loanRepository.countOverdueLoans();
            
            Health.Builder status = Health.up();
            
            if (overdueCount > 100) {
                status = Health.down()
                    .withDetail("reason", "Too many overdue loans");
            }
            
            return status
                .withDetail("database", "Available")
                .withDetail("overdueLoans", overdueCount)
                .withDetail("timestamp", LocalDateTime.now())
                .build();
                
        } catch (Exception ex) {
            return Health.down(ex)
                .withDetail("database", "Unavailable")
                .build();
        }
    }
}

@Component
public class CustomMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter loanCounter;
    private final Timer loanProcessingTimer;
    
    public CustomMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.loanCounter = Counter.builder("loans.created")
            .description("Number of loans created")
            .register(meterRegistry);
        this.loanProcessingTimer = Timer.builder("loan.processing.time")
            .description("Loan processing time")
            .register(meterRegistry);
    }
    
    public void incrementLoanCount() {
        loanCounter.increment();
    }
    
    public Timer.Sample startLoanTimer() {
        return Timer.start(meterRegistry);
    }
}
```

#### 9.3 애플리케이션 성능 모니터링 (APM)
```java
@Configuration
public class MonitoringConfig {
    
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config()
            .commonTags("application", "bookstore-system")
            .commonTags("environment", getEnvironment());
    }
    
    @EventListener
    public void handleLoanCreated(LoanCreatedEvent event) {
        // 대여 생성 메트릭 증가
        Metrics.counter("loan.created", 
            "member.type", event.getMember().getMembershipType().name()
        ).increment();
        
        // 도서별 대여 횟수 추적
        Metrics.counter("loan.by.book",
            "book.id", event.getBook().getId().toString(),
            "book.title", event.getBook().getTitle()
        ).increment();
    }
}
```

### 10. 캐싱 전략

#### 10.1 다층 캐싱 아키텍처
```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager.Builder builder = RedisCacheManager
            .RedisCacheManagerBuilder
            .fromConnectionFactory(redisConnectionFactory())
            .cacheDefaults(cacheConfiguration(Duration.ofMinutes(10)));
        
        return builder.build();
    }
    
    private RedisCacheConfiguration cacheConfiguration(Duration ttl) {
        return RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(ttl)
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
    }
}
```

#### 10.2 서비스별 캐싱 전략
**도서 정보 캐싱 (읽기 집약적):**
```java
@Service
public class BookServiceImpl implements BookService {
    
    @Cacheable(value = "books", key = "#id", unless = "#result == null")
    public BookResponse findBookById(Long id) {
        log.debug("도서 조회 - DB에서 조회: {}", id);
        return bookRepository.findById(id)
            .map(BookResponse::from)
            .orElseThrow(() -> new EntityNotFoundException("Book not found: " + id));
    }
    
    @CacheEvict(value = "books", key = "#bookId")
    public BookResponse updateBook(Long bookId, UpdateBookRequest request) {
        log.debug("도서 정보 업데이트 - 캐시 무효화: {}", bookId);
        // 업데이트 로직...
        return BookResponse.from(updatedBook);
    }
    
    @Cacheable(value = "availableBooks", key = "'available'")
    public List<BookResponse> findAvailableBooks() {
        log.debug("대여 가능 도서 목록 조회 - DB에서 조회");
        return bookRepository.findByAvailableTrue()
            .stream()
            .map(BookResponse::from)
            .collect(Collectors.toList());
    }
    
    @CacheEvict(value = "availableBooks", key = "'available'")
    public void updateBookAvailability(Long bookId, boolean available) {
        log.debug("도서 가용성 변경 - 캐시 무효화: {} -> {}", bookId, available);
        // 가용성 업데이트 로직...
    }
}
```

**통계 데이터 캐싱 (계산 집약적):**
```java
@Service
public class StatisticsServiceImpl implements StatisticsService {
    
    @Cacheable(value = "loan-statistics", 
               key = "#filter.startDate + '-' + #filter.endDate",
               condition = "#filter.cacheable")
    public LoanStatisticsResponse getLoanStatistics(StatisticsFilter filter) {
        log.debug("대여 통계 계산 - 기간: {} ~ {}", 
            filter.getStartDate(), filter.getEndDate());
            
        // 복잡한 집계 쿼리 실행
        return buildLoanStatistics(filter);
    }
    
    @Cacheable(value = "popular-books", key = "#limit")
    public List<PopularBookResponse> getPopularBooks(int limit) {
        log.debug("인기 도서 조회 - 상위 {}권", limit);
        return loanRepository.findPopularBooks(limit)
            .stream()
            .map(PopularBookResponse::from)
            .collect(Collectors.toList());
    }
    
    @Scheduled(fixedRate = 3600000) // 1시간마다
    @CacheEvict(value = {"loan-statistics", "popular-books"}, allEntries = true)
    public void refreshStatisticsCache() {
        log.info("통계 캐시 갱신 시작");
        // 주요 통계 데이터 프리로딩
        preloadStatistics();
        log.info("통계 캐시 갱신 완료");
    }
}
```

#### 10.3 캐시 무효화 전략
```java
@Component
@EventListener
public class CacheEvictionHandler {
    
    private final CacheManager cacheManager;
    
    @EventListener
    public void handleLoanCreated(LoanCreatedEvent event) {
        // 도서 가용성 캐시 무효화
        evictCache("availableBooks", "available");
        
        // 회원별 대여 통계 캐시 무효화
        evictCache("member-loans", event.getMember().getId().toString());
        
        // 인기 도서 캐시 무효화 (대여가 발생했으므로)
        evictCache("popular-books");
    }
    
    @EventListener
    public void handleBookReturned(BookReturnedEvent event) {
        // 도서 가용성 캐시 무효화
        evictCache("availableBooks", "available");
        
        // 연체 관련 캐시 무효화
        evictCache("overdue-statistics");
    }
    
    private void evictCache(String cacheName, String... keys) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            if (keys.length == 0) {
                cache.clear();
                log.debug("캐시 전체 무효화: {}", cacheName);
            } else {
                for (String key : keys) {
                    cache.evict(key);
                    log.debug("캐시 무효화: {} - {}", cacheName, key);
                }
            }
        }
    }
}
```

#### 10.4 캐시 성능 모니터링
```java
@Component
public class CacheMetrics {
    
    @EventListener
    public void handleCacheHit(CacheHitEvent event) {
        Metrics.counter("cache.hit", 
            "cache", event.getCacheName(),
            "key", event.getKey().toString()
        ).increment();
    }
    
    @EventListener  
    public void handleCacheMiss(CacheMissEvent event) {
        Metrics.counter("cache.miss",
            "cache", event.getCacheName(),
            "key", event.getKey().toString()
        ).increment();
    }
    
    @Scheduled(fixedRate = 60000) // 1분마다
    public void reportCacheStatistics() {
        cacheManager.getCacheNames().forEach(cacheName -> {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache instanceof RedisCache) {
                // Redis 캐시 통계 수집
                reportRedisCacheStats(cacheName);
            }
        });
    }
}

### 6. 성능 최적화 시나리오

#### 6.1 캐싱 적용
- 자주 조회되는 도서 정보를 Redis에 캐싱한다
- 대여 가능 여부 확인 시 캐시를 우선 조회한다

#### 6.2 배치 처리
- 연체 확인 및 알림 발송을 배치 작업으로 처리한다
- 통계 데이터를 주기적으로 집계하여 조회 성능을 개선한다

## 예외 시나리오

### 7.1 결제 실패
- 결제 처리 중 오류 발생 시 주문을 CANCELLED 상태로 변경한다
- 회원에게 결제 실패 알림을 발송한다

### 7.2 시스템 장애
- 데이터베이스 연결 실패 시 적절한 오류 메시지를 반환한다
- 외부 결제 시스템 장애 시 대기열에 추가하여 재시도한다

### 7.3 동시성 문제
- 동일한 도서에 대한 동시 대여 신청 시 선착순으로 처리한다
- 낙관적 락을 사용하여 데이터 일관성을 보장한다