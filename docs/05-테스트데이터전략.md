# 테스트 데이터 관리 전략

## 🎯 문제 인식

### 기존 테스트의 문제점
1. **data.sql 의존성**: 기본 데이터에 의존하여 테스트가 불안정
2. **데이터 격리 부족**: 테스트 간 데이터 간섭으로 예측 불가능한 결과
3. **상위 도메인 테스트 어려움**: 기본 데이터가 필요한 도메인 테스트 복잡도 증가
4. **테스트 원시성 부족**: 테스트가 외부 요인에 영향받아 신뢰도 저하

## 🏗️ 해결 전략

### 1. 계층화된 테스트 데이터 관리

#### 1.1 TestDataBuilder 패턴
```java
@TestConfiguration
public class TestDataConfig {
    @Bean
    public TestDataBuilder testDataBuilder() {
        return new TestDataBuilder();
    }
    
    public static class TestDataBuilder {
        // 엔티티별 기본/커스텀 생성 메서드
        public Member createDefaultMember() { ... }
        public Member createMember(String name, String email, MembershipType type) { ... }
        public Book createBook(String title, String author, ...) { ... }
    }
}
```

**장점:**
- 재사용 가능한 테스트 데이터 생성
- 일관된 데이터 구조 보장
- 테스트별 필요 데이터만 선택적 생성

#### 1.2 TestScenario 패턴
```java
public class TestScenario {
    // 시나리오별 데이터 컨테이너
    public static class LoanScenario {
        private final Member regularMember;    // 5권 제한
        private final Member premiumMember;    // 10권 제한
        private final Member suspendedMember;  // 대여 불가
        private final Book availableBook;
        private final List<Loan> existingLoans; // 제한 테스트용
    }
}
```

**장점:**
- 비즈니스 시나리오별 데이터 그룹화
- 복잡한 테스트 케이스 단순화
- 테스트 의도 명확화

#### 1.3 TestDataManager
```java
@Component
public class TestDataManager {
    public TestScenario.LoanScenario createLoanScenario(TestEntityManager entityManager) {
        // 대여 관련 모든 테스트 데이터를 일괄 생성
        // 회원(3종류) + 도서(2종류) + 기존대여(4개)
    }
}
```

**장점:**
- 복잡한 데이터 관계 자동 구성
- 테스트 시나리오별 최적화된 데이터 제공
- 테스트 코드에서 데이터 생성 로직 분리

### 2. 테스트 격리 전략

#### 2.1 @Transactional + @Rollback
```java
@DataJpaTest  // 자동으로 @Transactional + @Rollback
class MemberRepositoryTest {
    // 각 테스트 메서드 후 자동 롤백
}
```

#### 2.2 고유 데이터 생성
```java
@Test
void findByEmail_존재하는이메일_회원반환() {
    // 타임스탬프를 활용한 고유 데이터
    String uniqueEmail = "test." + System.currentTimeMillis() + "@example.com";
    Member member = testDataBuilder.createMember("테스트", uniqueEmail, REGULAR);
    // ...
}
```

#### 2.3 테스트별 독립적 데이터 생성
```java
@Test
void checkLoanLimit_Regular회원_5권제한확인() {
    // data.sql과 무관하게 필요한 데이터만 생성
    TestScenario.LoanScenario scenario = testDataManager.createLoanScenario(entityManager);
    // 완전히 독립적인 테스트 실행
}
```

### 3. data.sql 활용 전략

#### 3.1 data.sql 역할 재정의
- **목적**: 애플리케이션 실행 시 기본 데이터 제공
- **범위**: 개발/데모 환경에서만 사용
- **테스트와의 관계**: 테스트는 data.sql에 의존하지 않음

#### 3.2 프로파일별 분리
```yaml
# application-test.yml
spring:
  sql:
    init:
      mode: never  # 테스트 시 data.sql 실행하지 않음
  jpa:
    defer-datasource-initialization: false
```

```yaml
# application-dev.yml  
spring:
  sql:
    init:
      mode: always  # 개발 시에는 data.sql 실행
```

## 🔍 구체적 적용 사례

### Case 1: Repository 테스트

#### ❌ 기존 방식 (data.sql 의존)
```java
@Test
void findByMembershipType_REGULAR_회원조회() {
    List<Member> members = memberRepository.findByMembershipType(REGULAR);
    assertThat(members).hasSize(2); // data.sql에 REGULAR 2명이 있다고 가정
}
```
**문제점:** data.sql 변경 시 테스트 실패

#### ✅ 개선된 방식 (독립적 데이터)
```java
@Test  
void findByMembershipType_REGULAR_회원조회() {
    // Given - 테스트용 데이터만 생성
    Member regular1 = testDataBuilder.createMember("정규1", "r1@test.com", REGULAR);
    Member regular2 = testDataBuilder.createMember("정규2", "r2@test.com", REGULAR);
    Member premium = testDataBuilder.createPremiumMember("프리미엄", "p@test.com");
    
    entityManager.persist(regular1);
    entityManager.persist(regular2);  
    entityManager.persist(premium);
    entityManager.flush();
    
    // When
    List<Member> members = memberRepository.findByMembershipType(REGULAR);
    
    // Then - 정확히 생성한 2명만 확인
    assertThat(members)
        .extracting(Member::getName)
        .contains("정규1", "정규2")
        .doesNotContain("프리미엄");
}
```

### Case 2: Service 테스트 (복잡한 비즈니스 로직)

#### ✅ 시나리오 기반 테스트
```java
@Test
void loanBook_Regular회원5권제한_초과시예외발생() {
    // Given - 이미 4권 대여 중인 상황 시나리오
    TestScenario.LoanScenario scenario = testDataManager.createLoanScenario(entityManager);
    
    assertThat(scenario.getRegularMemberLoanCount()).isEqualTo(4);
    assertThat(scenario.isRegularMemberNearLimit()).isTrue();
    
    // When & Then - 5번째는 성공, 6번째부터 실패
    // ... 비즈니스 로직 테스트
}
```

### Case 3: 통합 테스트

#### ✅ 복합 시나리오 활용
```java
@Test
void 회원가입부터대여까지_전체플로우_정상동작() {
    // Given - 복합 시나리오 (회원+도서+기존대여+주문)
    TestScenario.ComplexScenario scenario = testDataManager.createComplexScenario(entityManager);
    
    // When & Then - 전체 비즈니스 플로우 테스트
    // 1. 신규 회원 등록
    // 2. 도서 대여
    // 3. 제한 확인
    // 4. 알림 발송 등
}
```

## 📋 구현 가이드

### 1. 프로젝트 구조
```
src/test/java/com/example/spring/
├── config/
│   ├── TestDataConfig.java      # 테스트 데이터 빌더
│   ├── TestDataManager.java     # 시나리오 매니저
│   └── TestScenario.java        # 시나리오 컨테이너
├── repository/
│   └── *RepositoryTestV2.java   # 개선된 Repository 테스트
└── service/  
    └── *ServiceTest.java        # 시나리오 기반 Service 테스트
```

### 2. 테스트 작성 체크리스트

#### ✅ Repository 테스트
- [ ] @DataJpaTest + 필요 구현체만 @Import
- [ ] TestDataBuilder로 필요 데이터만 생성
- [ ] 고유 식별자(타임스탬프) 활용
- [ ] data.sql 독립적 검증

#### ✅ Service 테스트  
- [ ] 적절한 TestScenario 선택/생성
- [ ] Mock vs 실제 Repository 판단
- [ ] 비즈니스 로직에 집중한 테스트
- [ ] 복잡한 상태 설정은 TestDataManager 활용

#### ✅ 통합 테스트
- [ ] @SpringBootTest + @Transactional
- [ ] ComplexScenario로 종합 데이터 준비
- [ ] 전체 플로우 검증
- [ ] 성능 영향 최소화

## 🎯 기대 효과

### 1. 테스트 안정성 향상
- data.sql 변경에 영향받지 않는 독립적 테스트
- 예측 가능하고 반복 가능한 테스트 결과

### 2. 테스트 작성 효율성
- 재사용 가능한 테스트 데이터 컴포넌트
- 시나리오별 최적화된 데이터 준비

### 3. 유지보수성 개선
- 테스트 의도가 명확한 코드
- 데이터 변경 시 영향 범위 최소화

### 4. 상위 도메인 테스트 가능
- 복잡한 의존성을 가진 도메인도 쉽게 테스트
- 비즈니스 로직에 집중한 테스트 작성

---

**결론**: 이 전략을 통해 data.sql과 독립적이면서도 실용적인 테스트 환경을 구축할 수 있으며, 테스트의 원시성과 신뢰성을 크게 향상시킬 수 있습니다.